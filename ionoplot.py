# -*- coding: utf-8 -*-
"""Practice.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18z9orDbLZQpNV9jI1mjuE2zzPS2ueL1-

# Usage

This notebook is distributed using MIT licence

    MIT License

    Copyright (c) [2023] [Artem Vesnin]

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.

# Site the paper if you use this code for research

    Vesnin, A., Yasyukevich, Y., Perevalova, N., & Şentürk, E. (2023). Ionospheric Response to the 6 February 2023 Turkey–Syria Earthquake. Remote Sensing, 15(9), 2336.


# Data availabilty

Data of global GNSS network are available at https://simurg.space, ionosonde data availabel through https://giro.uml.edu. The data paper uses along with notebook (with outputs preserved) are available here https://cloud.iszf.irk.ru/index.php/s/3RcnGdohf38kmAO .  Email artem_vesnin@iszf.irk.ru if you have any questions about data format or behaviour of particular piece of code.

# Prepare environment

Load anaconda to make sure we are on the same page.

https://docs.conda.io/en/latest/

In anaconda propmt (or in linux bash):

```bash
conda deactivate
conda create -n turkey_eq python=3.10
conda activate turkey_eq
conda install jupyterlab
conda install cartopy
jupyter-notebook
```

# Install requirements
"""
#
# !pip install requests
# !pip install h5py
# !pip install numpy
# !pip install matplotlib
# !pip install scipy

"""# Load data

We already collect data and provide urls below. You can do it by your own on SIMuRG site under [create_map](https://simurg.iszf.irk.ru/create_map) option.
"""

import requests
import os
URLS = {"roti_10_24.h5":
            "https://simurg.space/files/roti_2023_037_25_50_N_25_50_E_645f.h5",
        "dtec_2_10_10_24.h5":
            "https://simurg.space/files/dtec_2_10_2023_037_25_50_N_25_50_E_1447.h5",
        "dtec_10_20_10_24.h5":
            "https://simurg.space/files/dtec_10_20_2023_037_25_50_N_25_50_E_840f.h5",
        "dtec_20_60_10_24.h5":
            "https://simurg.space/files/dtec_20_60_2023_037_25_50_N_25_50_E_6769.h5",
        "roti_01_17.h5":
            "https://simurg.space/files/roti_2023_037_25_50_N_25_50_E_c5ab.h5",
        "dtec_2_10_01_17.h5":
            "https://simurg.space/files/dtec_2_10_2023_037_25_50_N_25_50_E_421a.h5",
        "dtec_10_20_01_17.h5":
            "https://simurg.space/files/dtec_10_20_2023_037_25_50_N_25_50_E_2051.h5",
        "dtec_20_60_01_17.h5":
            "https://simurg.space/files/dtec_20_60_2023_037_25_50_N_25_50_E_b483.h5",
       }

URLS.update({ "roti_10_24.h5":
                    "https://simurg.space/ufiles/roti_2023_037_25_50_N_25_50_E_8fc2.h5",
              "dtec_2_10_10_24.h5":
                    "https://simurg.space/ufiles/dtec_2_10_2023_037_25_50_N_25_50_E_cfeb.h5",
              "dtec_10_20_10_24.h5":
                    "https://simurg.space/ufiles/dtec_10_20_2023_037_25_50_N_25_50_E_3290.h5",
              "dtec_20_60_10_24.h5":
                    "https://simurg.space/ufiles/dtec_20_60_2023_037_25_50_N_25_50_E_30d5.h5",
              "roti_01_17.h5":
                  "https://simurg.space/ufiles/roti_2023_037_25_50_N_25_50_E_d6aa.h5",
              "dtec_2_10_01_17.h5":
                  "https://simurg.space/ufiles/dtec_2_10_2023_037_25_50_N_25_50_E_44e1.h5",
              "dtec_10_20_01_17.h5":
                  "https://simurg.space/ufiles/dtec_10_20_2023_037_25_50_N_25_50_E_d0de.h5",
              "dtec_20_60_01_17.h5":
                  "https://simurg.space/ufiles/dtec_20_60_2023_037_25_50_N_25_50_E_77bc.h5"
            }
           )


FILES_PRODUCT_10_24 = {"roti_10_24.h5": "ROTI",
                       "dtec_2_10_10_24.h5": "2-10 minute TEC variations",
                       "dtec_10_20_10_24.h5": "10-20 minute TEC variations",
                       "dtec_20_60_10_24.h5": "20-60 minute TEC variations",
                      }

FILES_PRODUCT_01_17 = {"roti_01_17.h5": "ROTI",
                       "dtec_2_10_01_17.h5": "2-10 minute TEC variations",
                       "dtec_10_20_01_17.h5": "10-20 minute TEC variations",
                       "dtec_20_60_01_17.h5": "20-60 minute TEC variations",
                      }

TNPGN_FILES_PRODUCT_10_24 = {"tnpgn_roti_10_24.h5": "ROTI",
                             "tnpgn_dtec_2_10_10_24.h5": "2-10 minute TEC variations",
                             "tnpgn_dtec_10_20_10_24.h5": "10-20 minute TEC variations",
                             "tnpgn_dtec_20_60_10_24.h5": "20-60 minute TEC variations",
                            }

TNPGN_FILES_PRODUCT_01_17 = {"tnpgn_roti_01_17.h5": "ROTI",
                             "tnpgn_dtec_2_10_01_17.h5": "2-10 minute TEC variations",
                             "tnpgn_dtec_10_20_01_17.h5": "10-20 minute TEC variations",
                             "tnpgn_dtec_20_60_01_17.h5": "20-60 minute TEC variations",
                            }

for local_file, url in URLS.items():
    if not os.path.exists(local_file):
        response = requests.get(url)
        open(local_file, "wb").write(response.content)

"""# Including necessary packages"""

# !pip install cartopy
import cartopy

import h5py
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as dt
import matplotlib.dates as mdates
import datetime
import cartopy.crs as ccrs
from cartopy import feature
from cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER
from datetime import (datetime,
                      timedelta)
from dateutil import tz
from collections import defaultdict
from pathlib import Path

# TECu - Total Electron Content Unit
# ROTI Maps
# tnpgn - Turkish National Permanent GNSS Network
# Global Navigation Satellite System (GNSS)
# DTEC (Differential Total Electron Content)
# VTEC (Vertical Total Electron Content)

"""# Define some constants"""

C_LIMITS ={
    'ROTI': [-0,0.5,'TECu/min'],
    '2-10 minute TEC variations': [-0.2,0.2,'TECu'],
    '10-20 minute TEC variations': [-0.4,0.4,'TECu'],
    '20-60 minute TEC variations': [-0.6,0.6,'TECu'],
    'tec': [0,50,'TECu/min'],
    'tec_adjusted': [0,50,'TECu'],
}

DEFAULT_PARAMS = {'font.size': 20,
                  'figure.dpi': 300,
                  'font.family': 'sans-serif',
                  'font.style': 'normal',
                  'font.weight': 'light',
                  'legend.frameon': True,
                  'font.variant' : 'small-caps',
                  'axes.titlesize' : 20,
                  'axes.labelsize' : 20,
                  'xtick.labelsize' : 18,
                  'xtick.major.pad': 5,
                  'ytick.major.pad': 5,
                  'xtick.major.width' : 2.5,
                  'ytick.major.width' : 2.5,
                  'xtick.minor.width' : 2.5,
                  'ytick.minor.width' : 2.5,
                  'ytick.labelsize' : 20}

TIME_FORMAT = '%Y-%m-%d %H:%M:%S.%f'

EPICENTERS = {'01:17': {'lat': 37.220,
                        'lon': 37.019,
                        'time': datetime(2023, 2, 6, 1, 17, 34)},
              '10:24': {'lat': 38.016,
                        'lon': 37.206,
                        'time': datetime(2023, 2, 6, 10, 24, 50)}
             }

_UTC = tz.gettz('UTC')

"""# Retrieve and plot methods"""


def _prepare_layout(ax,
                    lon_limits,
                    lat_limits):
    """Настраивает отображение"""
    plt.rcParams.update(DEFAULT_PARAMS)
    gl = ax.gridlines(linewidth=2, color='gray', alpha=0.5, draw_labels=True, linestyle='--')
    gl.top_labels = False
    gl.right_labels = False
    gl.xformatter = LONGITUDE_FORMATTER
    gl.yformatter = LATITUDE_FORMATTER
    ax.set_xlim(*lon_limits)
    ax.set_ylim(*lat_limits)
    #put some features on the map
    ax.add_feature(feature.COASTLINE, linewidth=2.5)
    ax.add_feature(feature.BORDERS, linestyle=':', linewidth=2)
    ax.add_feature(feature.LAKES, alpha=0.5)
    ax.add_feature(feature.RIVERS)

#Plot data for one time moment
def plot_map(plot_times, data, type_d,
             lon_limits=(-180, 180),
             lat_limits=(-90, 90),
             nrows=1,
             ncols=3,
             markers=[],
             sort=False,
             use_alpha=False,
             c_limits=C_LIMITS,
             save_path=None):
    """
    Plotting data
    input - <time> string type time from SIMuRG map file
            <lats> list of latitudes
            <lons> list of longitudes
            <values> list of values
            <type_d> string type of data going to be plotted
    output - figure
    """
    assert len(plot_times) == ncols
    if isinstance(type_d, list):
        assert len(type_d) == nrows
    else:
        type_d = [type_d]
    fig, axs = plt.subplots(nrows=nrows,ncols=ncols,
                            subplot_kw={'projection': ccrs.PlateCarree()},
                            figsize=(6.7*ncols, 5.5*nrows))
    if nrows * ncols > 1:
        axs=axs.flatten()
    else:
        axs=[axs]

    #fig = plt.figure(figsize=(20, 8))
    #ax1 = plt.axes(projection=ccrs.PlateCarree())

    for iprod in range(nrows):
        for itime in range(ncols):
            ax1 = axs[itime + ncols * iprod]
            time = plot_times[itime]
            prod = type_d[iprod]
            if sort:
                arr = np.sort(data[prod][time], order='vals')
            else:
                arr = data[prod][time]
            lats = arr['lat']
            lons = arr['lon']
            values = arr['vals']

            _prepare_layout(ax1, lon_limits, lat_limits)
            if use_alpha: #Использовать прозрачность у точек или нет
                m = max(np.max(values), -np.min(values))
                alphas = [(v+m/4)/(m+m/4) for v in values]
                alphas = [abs(a) for a in alphas]
            else:
                alphas = [1 for _ in values]

            sctr = ax1.scatter(lons, lats, c=values,
                               alpha = alphas,
                               marker = 's', s =15, zorder=3,
                               vmin = c_limits[prod][0],
                               vmax = c_limits[prod][1],
                               cmap = 'jet')
            for marker in markers: #расстановка звёздочек
                ax1.scatter(marker['lon'], marker['lat'],
                            marker='*', color="black", s=400,
                            zorder=5)
            if iprod == 0: #заголовок, если строк с картинками несколько
                ax1.set_title(time.strftime(TIME_FORMAT)[:-7]+'\n'+prod)
            else:
                ax1.set_title('\n'+prod)
            if itime % ncols == ncols - 1:
                cax = fig.add_axes([ax1.get_position().x1+0.01,
                                    ax1.get_position().y0,
                                    0.02,
                                    ax1.get_position().height])
                cbar = ax1.figure.colorbar(sctr, cax=cax) #color bar
                cbar_label = c_limits[prod][2] + "\n" if type_d == "ROTI" else c_limits[prod][2]
                cbar.ax.set_ylabel(cbar_label, rotation=-90, va="bottom")

            ax1.xaxis.set_ticks_position('none')

            if save_path:
                plt.savefig(save_path)

    if not save_path:
        plt.show()
    plt.close()
    plt.rcdefaults()


#Read data from h5 file to python dict
def retrieve_data(file, type_d, times=[]):
    """
    Plotting data from map file
    input - <file> string type name of file
            <type_d> string type of data going to be plotted
    output - figures
    """
    with h5py.File(file, 'r') as f_in:
        lats = []
        lons = []
        values = []
        data = {}
        for str_time in list(f_in['data'])[:]:
            time = datetime.strptime(str_time, TIME_FORMAT)
            time = time.replace(tzinfo=time.tzinfo or _UTC)
            if times and time not in times:
                continue
            data[time] = f_in['data'][str_time][:]
    return data

def retrieve_data_multiple_source(files, type_d, times=[]):
    datas = defaultdict(list)
    for file in files:
        file_data = retrieve_data(file, type_d, times=times)
        for time, data in file_data.items():
            datas[time].append(data)
    for time in datas:
        datas[time] = np.concatenate(datas[time])
    return datas

#prod - product
# times - array with time need to be select from the files
def plot_maps(prod_files, prods, epicenters, c_limits=None, times=None, scale=1):
    if not isinstance(epicenters, list):
        epicenters = [epicenters]
    if c_limits:
        C_LIMITS = c_limits
    else:
        C_LIMITS ={
            'ROTI': [0,0.5*scale,'TECu/min'],
            '2-10 minute TEC variations': [-0.4*scale,0.4*scale,'TECu'],
            '10-20 minute TEC variations': [-0.6*scale,0.6*scale,'TECu'],
            '20-60 minute TEC variations': [-1*scale,1*scale,'TECu'],
            'tec': [0,50*scale,'TECu/min'],
            'tec_adjusted': [0,50*scale,'TECu'],
        }
    if times: #todo
        pass
    else:
        times = [datetime(2023, 2, 6, 10, 25),
                 datetime(2023, 2, 6, 10, 40),
                 datetime(2023, 2, 6, 10, 45, 0)]
    times = [t.replace(tzinfo=t.tzinfo or _UTC) for t in times]
    # t = list(zip(*prod_files))
    for files in zip(*prod_files):
        data = retrieve_data_multiple_source(files, prods[files[0]], times)
        data = {prods[files[0]]: data}
        plot_map(times, data, prods[files[0]],
                 use_alpha=True,
                 lat_limits=(25, 50),
                 lon_limits=(25, 50),
                 sort=True,
                 markers=epicenters,
                 c_limits=C_LIMITS)

from enum import Enum
class MapType(Enum):
    ROTI = 'ROTI'
    TEC_2_10 = '2-10 minute TEC variations'
    TEC_10_20 = '10-20 minute TEC variations'
    TEC_20_60 = '20-60 minute TEC variations'
    TEC = 'tec'
    TEC_ADJUSTED = 'tec_adjusted'

# epicenter - dict with lat, lon
def my_plot_maps(files_path, map_type: MapType, times, epicenters, c_limits=None, scale=1, use_alpha=True, save_path=None):
    if not c_limits:
        c_limits={
            'ROTI': [0,0.5*scale,'TECu/min'],
            '2-10 minute TEC variations': [-0.4*scale,0.4*scale,'TECu'],
            '10-20 minute TEC variations': [-0.6*scale,0.6*scale,'TECu'],
            '20-60 minute TEC variations': [-1*scale,1*scale,'TECu'],
            'tec': [0,50*scale,'TECu/min'],
            'tec_adjusted': [0,50*scale,'TECu'],
        }
    type_d = map_type.value
    if not isinstance(files_path, list):
        files_path = [files_path]
    if not isinstance(epicenters, list):
        epicenters = [epicenters]

    times = [t.replace(tzinfo=t.tzinfo or _UTC) for t in times]

    data_from_files = retrieve_data_multiple_source(files_path, type_d, times)
    data = {type_d: data_from_files}
    plot_map(times, data, type_d,
             use_alpha=use_alpha,
             lat_limits=(25, 50),
             lon_limits=(25, 50),
             sort=True,
             markers=epicenters,
             c_limits=c_limits, save_path=save_path)

"""# Distance time"""

def get_dist_time(data, eq_location, direction='all'):
    x, y, c = [], [], []
    for time, map_data in data.items():
        lats = np.radians(map_data["lat"][:])
        lons = np.radians(map_data["lon"][:])
        vals = map_data["vals"][:]
        _eq_location = {}
        _eq_location["lat"] = np.radians(eq_location["lat"])
        _eq_location["lon"] = np.radians(eq_location["lon"])
        if direction == "all":
            inds = np.isreal(lats)
        elif direction == "north":
            inds = lats >= _eq_location["lat"]
        elif direction == "south":
            inds = lats <= _eq_location["lat"]
        elif direction == "east":
            inds = lats >= _eq_location["lon"]
        elif direction == "west":
            inds = lats <= _eq_location["lon"]
        else:
            inds = np.isreal(lats)
        lats = lats[inds]
        lons = lons[inds]
        vals = vals[inds]
        plats = np.zeros_like(lats)
        plons = np.zeros_like(lons)
        plats[:] = _eq_location["lat"]
        plons[:] = _eq_location["lon"]

        dists = great_circle_distance_numpy(lats,lons,
                                            plats, plons)


        x.extend([time] * len(vals))
        y.extend(dists / 1000)
        c.extend(vals)
    return x, y, c


def my_plot_distance_time(file_path, map_type: MapType, epicenter, sort = True, line=dict(), c_limits=None, dmax=1750, save_path=None):
    if not c_limits:
        c_limits = {
            'ROTI': [-0, 0.5, 'TECu/min\n'],
            '2-10 minute TEC variations': [-0.6, 0.6, 'TECu'],
            '10-20 minute TEC variations': [-0.8, 0.8, 'TECu'],
            '20-60 minute TEC variations': [-1.0, 1.0, 'TECu'],
            'tec': [0, 50, 'TECu/min'],
            'tec_adjusted': [0, 50, 'TECu'],
        }

    ptype = map_type.value
    data = retrieve_data(file_path, ptype)
    x, y, c = get_dist_time(data, epicenter)

    c_abs = [abs(_c) for _c in c]
    if sort:
        x = [i for _, i in sorted(zip(c_abs, x))]
        y = [i for _, i in sorted(zip(c_abs, y))]
        c = [i for _, i in sorted(zip(c_abs, c))]
        # x = [i for _, i in sorted(zip(c, x))]
        # y = [i for _, i in sorted(zip(c, y))]
        # c.sort()

    times = [t for t in data]
    times.sort()
    plt.figure(figsize=(18, 5))
    plt.rcParams.update(DEFAULT_PARAMS)
    plot_ax = plt.axes()
    plt.scatter(x, y, c=c, cmap='jet')
    cbar = plt.colorbar()
    plt.clim(c_limits[ptype][0], c_limits[ptype][1])
    plt.ylabel('Distance, km')

    dt_utc = times[-1].astimezone()
    formatted_string = dt_utc.strftime("UTC for %B %d, %Y") #'UTC for February 6, 2023'
    plt.title(formatted_string)

    plt.xlim(times[0], times[-1])
    plt.ylim(0, dmax)
    # plot vertical lines for earthquake times
    for epc, params in EPICENTERS.items():
        plt.axvline(x=params['time'], color='black', linewidth=3)
    cbar.ax.set_ylabel(c_limits[ptype][2], rotation=-90, va="bottom")
    plot_ax.xaxis.set_major_formatter(mdates.DateFormatter("%H:%M"))
    if save_path:
        plt.savefig(save_path)
    else:
        plt.show()

from numpy import pi, sin, cos, arccos, arcsin
from scipy.stats import norm

RE_meters = 6371000

def great_circle_distance_numpy(late, lone, latp, lonp, R=RE_meters):
    """
    Calculates arc length. Uses numpy arrays
    late, latp: double
        latitude in radians
    lone, lonp: double
        longitudes in radians
    R: double
        radius
    """
    lone[np.where(lone < 0)] = lone[np.where(lone < 0)] + 2*pi
    lonp[np.where(lonp < 0)] = lonp[np.where(lonp < 0)] + 2*pi
    dlon = lonp - lone
    inds = np.where((dlon > 0) & (dlon > pi))
    dlon[inds] = 2 * pi - dlon[inds]
    dlon[np.where((dlon < 0) & (dlon < -pi))] += 2 * pi
    dlon[np.where((dlon < 0) & (dlon < -pi))] = -dlon[np.where((dlon < 0) & (dlon < -pi))]
    cosgamma = sin(late) * sin(latp) + cos(late) * cos(latp) * cos(dlon)
    return R * arccos(cosgamma)

# plot_maps([FILES_PRODUCT_10_24, TNPGN_FILES_PRODUCT_10_24],
#           FILES_PRODUCT_10_24,
#           EPICENTERS['10:24'])
# plot_maps([FILES_PRODUCT_10_24],
#           FILES_PRODUCT_10_24,
#           EPICENTERS['10:24'])

times = [datetime(2023, 2, 6, 10, 25),
                 datetime(2023, 2, 6, 10, 40),
                 datetime(2023, 2, 6, 10, 45)]
# my_plot_maps(["roti_10_24.h5", "tnpgn_roti_10_24.h5"], MapType.ROTI, times, EPICENTERS['10:24'])

my_plot_distance_time("dtec_10_20_10_24.h5", MapType.TEC_10_20, EPICENTERS['10:24'], save_path="../out/time.png")
